
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import { toast } from 'sonner';
import type { Database } from './types';

const SUPABASE_URL = "https://xjxxuqqyjqzgmvtgrpgv.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhqeHh1cXF5anF6Z212dGdycGd2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE1MTEwNTksImV4cCI6MjA1NzA4NzA1OX0.ENwkIBR2DQBztLNrZB7oZ3JQ1zRKEAXWfyDTtjqPzOI";

// Track connection status
let isConnected = false;
let connectionAttempts = 0;
const MAX_RETRY_ATTEMPTS = 3;

// Create and export the supabase client
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
    storageKey: 'supabase.auth.token',
  },
});

// Initialize connection check
checkConnection();

// Function to check connection status
async function checkConnection() {
  try {
    connectionAttempts++;
    const { error } = await supabase.from('profiles').select('count', { count: 'exact', head: true });
    
    if (error) {
      console.error('Supabase connection error:', error);
      isConnected = false;
      
      // Only show toast after multiple failures to prevent spamming users
      if (connectionAttempts === MAX_RETRY_ATTEMPTS) {
        toast.error('Database connection issue', {
          description: 'Using local data instead',
          duration: 4000
        });
      }
      
      // Retry connection with exponential backoff
      if (connectionAttempts < MAX_RETRY_ATTEMPTS) {
        setTimeout(checkConnection, 1000 * Math.pow(2, connectionAttempts - 1));
      }
    } else {
      console.log('Supabase connection successful');
      isConnected = true;
      connectionAttempts = 0;
    }
  } catch (e) {
    console.error('Unexpected error checking Supabase connection:', e);
    isConnected = false;
  }
}

// Export connection status
export const getConnectionStatus = () => ({ 
  isConnected, 
  connectionAttempts,
  hasFailedCompletely: connectionAttempts >= MAX_RETRY_ATTEMPTS
});

// Enhanced wrapper for data operations with better error handling
export const safeDataOperation = async <T>(
  operation: () => Promise<T>,
  fallback: T,
  errorMessage = 'Data operation failed'
): Promise<T> => {
  if (!isConnected && connectionAttempts >= MAX_RETRY_ATTEMPTS) {
    console.log('Skipping Supabase operation, using fallback data');
    return fallback;
  }
  
  try {
    return await operation();
  } catch (error) {
    console.error(`${errorMessage}:`, error);
    toast.error('Data operation failed', {
      description: 'Please check your connection',
      duration: 3000
    });
    return fallback;
  }
};

// Export helper functions for working with health app data
export const healthAppsApi = {
  async getConnections(userId: string) {
    return safeDataOperation(
      async () => {
        const result = await supabase.rpc('get_fitness_connections', { user_id_param: userId });
        return { data: result.data || [], error: result.error };
      },
      { data: [], error: null },
      'Failed to fetch health connections'
    );
  },
  
  async getLatestHealthData(userId: string, provider: string, dataType: string) {
    return safeDataOperation(
      async () => {
        const result = await supabase.rpc('get_latest_fitness_data', { 
          user_id_param: userId,
          provider_param: provider,
          data_type_param: dataType
        });
        return { data: result.data || null, error: result.error };
      },
      { data: null, error: null },
      `Failed to fetch latest ${dataType} data`
    );
  },
  
  async getHealthDataHistory(userId: string, provider: string, dataType: string, limit = 30) {
    return safeDataOperation(
      async () => {
        const result = await supabase.rpc('get_fitness_data_history', {
          user_id_param: userId,
          provider_param: provider,
          data_type_param: dataType,
          limit_param: limit
        });
        return { data: result.data || [], error: result.error };
      },
      { data: [], error: null },
      `Failed to fetch ${dataType} history`
    );
  }
};
