
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { toast } from 'sonner';

const SUPABASE_URL = "https://xjxxuqqyjqzgmvtgrpgv.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhqeHh1cXF5anF6Z212dGdycGd2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE1MTEwNTksImV4cCI6MjA1NzA4NzA1OX0.ENwkIBR2DQBztLNrZB7oZ3JQ1zRKEAXWfyDTtjqPzOI";

// Maximum number of retries for operations
const MAX_RETRIES = 3;
// Base delay before retrying (in ms) - will be multiplied by attempt number
const RETRY_DELAY = 1000;

// Create and export the supabase client with enhanced configuration
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
    storageKey: 'supabase.auth.token',
  },
  global: {
    // Add headers that help with request identification
    headers: {
      'x-application-name': 'optm-healthpro',
    },
    // Fetch options to enhance reliability
    fetch: (url, options = {}) => {
      // Extend timeout for fetch operations
      const timeoutController = new AbortController();
      const timeoutId = setTimeout(() => timeoutController.abort(), 15000); // 15s timeout
      
      return fetch(url, {
        ...options,
        signal: timeoutController.signal,
      }).finally(() => {
        clearTimeout(timeoutId);
      });
    },
  },
  // Realtime subscription configuration with auto-reconnect enabled
  realtime: {
    params: {
      eventsPerSecond: 5,
    },
  },
});

/**
 * Enhanced Supabase query executor with retry logic
 * @param operation - Function that performs a Supabase operation
 * @param options - Configuration options
 * @returns The result of the operation
 */
export async function withRetry<T>(
  operation: () => Promise<T>, 
  options: { 
    retries?: number; 
    showToastOnError?: boolean;
    errorMessage?: string;
  } = {}
): Promise<T> {
  const { 
    retries = MAX_RETRIES, 
    showToastOnError = false,
    errorMessage = "Supabase operation failed"
  } = options;
  
  let lastError: Error | null = null;
  
  for (let attempt = 0; attempt < retries; attempt++) {
    try {
      // Execute the operation
      return await operation();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      console.error(`Supabase operation failed (attempt ${attempt + 1}/${retries}):`, error);
      
      // Only wait if we're going to retry
      if (attempt < retries - 1) {
        // Exponential backoff
        const delay = RETRY_DELAY * Math.pow(2, attempt);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  // If we get here, all retries failed
  if (showToastOnError) {
    toast.error(errorMessage, {
      description: lastError?.message || "Please try again later",
      duration: 5000,
    });
  }
  
  throw lastError || new Error("Operation failed after multiple retries");
}

/**
 * Connection status checker
 * @returns True if Supabase is reachable, false otherwise
 */
export async function checkSupabaseConnection(): Promise<boolean> {
  try {
    // Simple health check against Supabase
    const { data, error } = await supabase.from('profiles').select('count', { count: 'exact' }).limit(1);
    return !error;
  } catch (error) {
    console.error('Supabase connection check failed:', error);
    return false;
  }
}
